# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T17:49:12+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBasic
from fastapi import Path, Query, UploadFile

from models import (
    Account,
    AddContactListContactsRequest,
    AddDoNotContactRequest,
    ApiCredential,
    ApiCredentialPage,
    Batch,
    BatchPage,
    BatchRequest,
    BillingPlanUsage,
    Call,
    CallBroadcast,
    CallBroadcastPage,
    CallBroadcastStats,
    CallCreateSound,
    CallerIdList,
    CallerIdVerificationRequest,
    CallList,
    CallPage,
    CallRecording,
    CallRecordingList,
    CallsBroadcastsIdRecipientsPostRequest,
    CallsBroadcastsIdToggleRecipientsStatusPostRequest,
    CallsPostRequest,
    CampaignSound,
    CampaignSoundPage,
    Contact,
    ContactHistory,
    ContactId,
    ContactList,
    ContactListPage,
    ContactPage,
    ContactsPostRequest,
    CreateContactListRequest,
    CreditUsage,
    DefaultVoice,
    DeliveryCategory,
    DeliveryState,
    DoNotContact,
    DoNotContactPage,
    ErrorResponse,
    Id,
    InputStream,
    ItemListUniversalDoNotContact,
    ItemListWebhookResource,
    KeywordConfig,
    KeywordLease,
    KeywordLeasePage,
    KeywordList,
    KeywordPurchaseRequest,
    Keywords,
    Media,
    MediaPage,
    Number1,
    NumberConfig,
    NumberConfigPage,
    NumberLease,
    NumberLeasePage,
    NumberList,
    NumberOrder,
    NumberPurchaseRequest,
    Page,
    PageDeliveryReport,
    PageNumberOrder,
    RegionPage,
    ResourceId,
    ResourceIdList,
    Status9,
    StreamingOutput,
    Text,
    TextAutoReply,
    TextAutoReplyPage,
    TextBroadcast,
    TextBroadcastCreateResponse,
    TextBroadcastPage,
    TextBroadcastStatsDto,
    TextList,
    TextPage,
    TextsBroadcastsIdRecipientsPostRequest,
    TextsBroadcastsIdToggleRecipientsStatusPostRequest,
    TextsPostRequest,
    TextToSpeech,
    UpdateContactListRequest,
    Webhook,
    WebhookPage,
    WebhookResource,
)

app = MCPProxy(
    contact={
        'email': 'support@callfire.com',
        'name': 'CallFire',
        'url': 'https://www.callfire.com',
    },
    description='CallFire',
    license={
        'name': 'Apache 2.0',
        'url': 'http://www.apache.org/licenses/LICENSE-2.0.html',
    },
    termsOfService='https://www.callfire.com/terms',
    title='CallFire API Documentation',
    version='V2',
    servers=[{'url': 'https://api.callfire.com/v2'}],
)


@app.get(
    '/calls',
    description=""" To search for all calls sent or received by the user. Use "id=0" for the campaignId parameter to query for all calls sent through the POST /calls API. See [call states and results](https://developers.callfire.com/results-responses-errors.html) """,
    tags=['call_management', 'campaign_batch_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_calls(
    fields: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    id: Optional[Id] = None,
    campaign_id: Optional[int] = Query(None, alias='campaignId'),
    batch_id: Optional[int] = Query(None, alias='batchId'),
    from_number: Optional[str] = Query(None, alias='fromNumber'),
    to_number: Optional[str] = Query(None, alias='toNumber'),
    label: Optional[str] = None,
    states: Optional[str] = None,
    results: Optional[str] = None,
    inbound: Optional[bool] = None,
    interval_begin: Optional[int] = Query(None, alias='intervalBegin'),
    interval_end: Optional[int] = Query(None, alias='intervalEnd'),
):
    """
    Find calls
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls',
    description=""" Use the /calls API to send individual calls quickly. A verified Caller ID and sufficient credits are required to make a call. CallRecipient represents a single recipient identified by phone number or contact id in CallFire system. You can attach user-defined attributes to a Call action via CallRecipient.attributes property, attributes are available in Call action response """,
    tags=['call_management', 'campaign_audio_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def send_calls(
    fields: Optional[str] = None,
    campaign_id: Optional[int] = Query(None, alias='campaignId'),
    default_live_message: Optional[str] = Query(None, alias='defaultLiveMessage'),
    default_machine_message: Optional[str] = Query(None, alias='defaultMachineMessage'),
    default_live_message_sound_id: Optional[int] = Query(
        None, alias='defaultLiveMessageSoundId'
    ),
    default_machine_message_sound_id: Optional[int] = Query(
        None, alias='defaultMachineMessageSoundId'
    ),
    default_voice: Optional[DefaultVoice] = Query(None, alias='defaultVoice'),
    strict_validation: Optional[bool] = Query(None, alias='strictValidation'),
    body: CallsPostRequest = None,
):
    """
    Send calls
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/broadcasts',
    description=""" Searches for all voice broadcasts created by user. Can query on label, name, and the current running status of the campaign. Returns a paged list of voice broadcasts """,
    tags=['call_management', 'call_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_call_broadcasts(
    fields: Optional[str] = None,
    limit: Optional[int] = 10,
    offset: Optional[int] = 0,
    label: Optional[str] = None,
    name: Optional[str] = None,
    running: Optional[bool] = None,
    scheduled: Optional[bool] = None,
    interval_begin: Optional[int] = Query(None, alias='intervalBegin'),
    interval_end: Optional[int] = Query(None, alias='intervalEnd'),
):
    """
    Find call broadcasts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/broadcasts',
    description=""" Creates a call broadcast campaign using the Call Broadcast API. Send a CallBroadcast in the message body to add details in a voice broadcast campaign. The campaign can be created without contacts and bare minimum configuration, but contacts will have to be added further on to use the campaign """,
    tags=['call_management', 'call_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_call_broadcast(
    start: Optional[bool] = None,
    strict_validation: Optional[bool] = Query(None, alias='strictValidation'),
    body: CallBroadcast = None,
):
    """
    Create a call broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/broadcasts/{id}',
    description=""" Returns a single CallBroadcast instance for a given call broadcast campaign id """,
    tags=['call_management', 'call_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_call_broadcast(id: int, fields: Optional[str] = None):
    """
    Find a specific call broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/calls/broadcasts/{id}',
    description=""" This operation lets the user modify the configuration of a voice broadcast campaign after call broadcast campaign is created. See CallBroadcast for more information on what can/can't be updated on this API """,
    tags=['call_management', 'call_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_call_broadcast(
    id: int,
    strict_validation: Optional[bool] = Query(None, alias='strictValidation'),
    body: CallBroadcast = None,
):
    """
    Update a call broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/broadcasts/{id}/archive',
    description=""" Archives a voice broadcast (voice broadcast will be hidden in search results) """,
    tags=['call_broadcast_management', 'call_management', 'media_file_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def archive_voice_broadcast(id: int):
    """
    Archive voice broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/broadcasts/{id}/batches',
    description=""" This endpoint will enable the user to page through all of the batches for a particular voice broadcast campaign """,
    tags=['call_management', 'call_broadcast_management', 'campaign_batch_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_call_broadcast_batches(
    id: int,
    fields: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
):
    """
    Find batches in a call broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/broadcasts/{id}/batches',
    description=""" The 'add batch' API allows user to add additional batches to an already created voice broadcast campaign. The added batch will go through the CallFire validation process, unlike in the recipients version of this API. That is why you can use the scrubDuplicates flag to remove duplicates from your batch. Batches may be added as a contact list id, a list of contact ids, or a list of numbers """,
    tags=['call_broadcast_management', 'campaign_batch_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def add_call_broadcast_batch(
    id: int,
    strict_validation: Optional[bool] = Query(None, alias='strictValidation'),
    body: BatchRequest = None,
):
    """
    Add batches to a call broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/broadcasts/{id}/calls',
    description=""" This endpoint will enable the user to page through all calls for a particular call broadcast campaign """,
    tags=['call_management', 'call_broadcast_management', 'campaign_batch_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_call_broadcast_calls(
    id: int,
    batch_id: Optional[int] = Query(None, alias='batchId'),
    fields: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
):
    """
    Find calls in a call broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/broadcasts/{id}/recipients',
    description=""" Use this API to add the recipients to an existing voice broadcast. Post a list of Recipient objects to be added to the voice broadcast campaign. These contacts will not go through validation process, and will be acted upon as they are added. Recipients may be added as a list of contact ids, or list of numbers """,
    tags=['call_management', 'call_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def add_call_broadcast_recipients(
    id: int,
    fields: Optional[str] = None,
    strict_validation: Optional[bool] = Query(None, alias='strictValidation'),
    body: CallsBroadcastsIdRecipientsPostRequest = None,
):
    """
    Add recipients to a call broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/broadcasts/{id}/start',
    description=""" Start a voice broadcast """,
    tags=['call_management', 'call_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def start_voice_broadcast(id: int):
    """
    Start voice broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/broadcasts/{id}/stats',
    description=""" Returns broadcast statistics like total number of sent/received actions, total cost, number of remaining outbound actions, error count, etc """,
    tags=['call_management', 'call_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_call_broadcast_stats(
    id: int,
    fields: Optional[str] = None,
    begin: Optional[int] = None,
    end: Optional[int] = None,
):
    """
    Get statistics on call broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/broadcasts/{id}/stop',
    description=""" Stop a voice broadcast """,
    tags=['call_management', 'call_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def stop_voice_broadcast(id: int):
    """
    Stop voice broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/calls/broadcasts/{id}/toggleRecipientsStatus',
    description=""" This operation lets the user to disable/enable undialed recipients in created broadcast """,
    tags=['call_broadcast_management', 'call_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def toggle_call_broadcast_recipients_status(
    id: int,
    enable: Optional[bool] = False,
    body: CallsBroadcastsIdToggleRecipientsStatusPostRequest = None,
):
    """
    Disable/enable undialed recipients in broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/recordings/{id}',
    description=""" Returns metadata of recording of a particular call. Metadata contains a link to a MP3 recording """,
    tags=['call_recording_access', 'call_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_call_recording(id: int, fields: Optional[str] = None):
    """
    Get call recording by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/recordings/{id}.mp3',
    description=""" Returns an MP3 recording of particular call, response contains binary data, content type is 'audio/mpeg' """,
    tags=['call_recording_access', 'media_file_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_call_recording_mp3(id: int):
    """
    Get call recording in mp3 format
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/{id}',
    description=""" Returns a single Call instance for a given call id. """,
    tags=['call_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_call(id: int, fields: Optional[str] = None):
    """
    Find a specific call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/{id}/recordings',
    description=""" Returns a list of recordings metadata of particular call. Metadata contains link to a MP3 recording """,
    tags=['call_recording_access', 'call_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_call_recordings(id: int, fields: Optional[str] = None):
    """
    Get call recordings for a call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/{id}/recordings/{name}',
    description=""" Returns recording metadata of particular call. Metadata contains link to a MP3 recording """,
    tags=['call_recording_access', 'call_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_call_recording_by_name(id: int, name: str = ..., fields: Optional[str] = None):
    """
    Get call recording by name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/calls/{id}/recordings/{name}.mp3',
    description=""" Returns a MP3 recording of a particular call, response contains binary data, content type is 'audio/mpeg' """,
    tags=['call_recording_access', 'media_file_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_call_recording_mp3_by_name(id: int, name: str = ...):
    """
    Get call mp3 recording by name
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/campaigns/batches/{id}',
    description=""" Returns a single Batch instance for a given batch id. This API is useful for determining the state of a validating batch """,
    tags=['campaign_batch_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_campaign_batch(id: int, fields: Optional[str] = None):
    """
    Find a specific batch
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/campaigns/batches/{id}',
    description=""" Updates a single Batch instance, currently batch can only be turned "on/off" """,
    tags=['call_broadcast_management', 'campaign_batch_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_campaign_batch(id: int, body: Batch = None):
    """
    Update a batch
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/campaigns/sounds',
    description=""" To find all campaign sounds which were created by user. Returns all sounds available to be used in campaigns """,
    tags=['campaign_audio_management', 'media_file_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_campaign_sounds(
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    filter: Optional[str] = None,
    include_archived: Optional[bool] = Query(None, alias='includeArchived'),
    include_pending: Optional[bool] = Query(None, alias='includePending'),
    include_scrubbed: Optional[bool] = Query(None, alias='includeScrubbed'),
    fields: Optional[str] = None,
):
    """
    Find sounds
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/campaigns/sounds/calls',
    description=""" Use this API to create a sound via a phone call. Provide the required phone number in the CallCreateSound object inside the request, and user will receive a call shortly after with instructions on how to record a sound over the phone. """,
    tags=['call_management', 'campaign_audio_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_call_campaign_sound(
    fields: Optional[str] = None, body: CallCreateSound = None
):
    """
    Add sound via call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/campaigns/sounds/files',
    description=""" Create a campaign sound file via a supplied .mp3 or .wav file """,
    tags=['campaign_audio_management', 'media_file_management', 'audio_file_handling'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_file_campaign_sound(fields: Optional[str] = None, file: UploadFile = ...):
    """
    Add sound via file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/campaigns/sounds/tts',
    description=""" Use this API to create a sound file via a supplied string of text. Add a text in the TextToSpeech.message field, and pick a voice in the TextToSpeech.voice field. Available voices are: MALE1, FEMALE1, FEMALE2, SPANISH1, FRENCHCANADIAN1 """,
    tags=['campaign_audio_management', 'media_file_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_t_t_s_campaign_sound(fields: Optional[str] = None, body: TextToSpeech = None):
    """
    Add sound via text-to-speech
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/campaigns/sounds/{id}',
    description=""" Deletes a single campaign sound instance for a specific campaign sound id, this operation does not delete sound completely, it sets sound status to ARCHIVED which means that sound will no longer appear in 'find' operation results, but still accessible via 'get' operation """,
    tags=['campaign_audio_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_campaign_sound(id: int):
    """
    Delete a specific sound
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/campaigns/sounds/{id}',
    description=""" Returns a single CampaignSound instance for a given sound id in campaign. This is a meta data to the sounds. No audio data is returned from this API """,
    tags=['campaign_audio_management', 'media_file_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_campaign_sound(id: int, fields: Optional[str] = None):
    """
    Find a specific sound
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/campaigns/sounds/{id}.mp3',
    description=""" Download the MP3 version of a hosted file. This is an audio data endpoint. Returns binary response of the 'audio/mpeg' content type """,
    tags=[
        'call_recording_access',
        'media_file_management',
        'campaign_audio_management',
        'audio_file_handling',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_campaign_sound_data_mp3(id: int):
    """
    Download a MP3 sound
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/campaigns/sounds/{id}.wav',
    description=""" Download the WAV version of the hosted file. This is an audio data endpoint. Returns binary response of the 'audio/mpeg' content type """,
    tags=['audio_file_handling', 'media_file_management', 'campaign_audio_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_campaign_sound_data_wav(id: int):
    """
    Download a WAV sound
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contacts',
    description=""" Find user's contacts by id, contact list, or on any property name. Returns a paged list of contacts """,
    tags=['contact_record_management', 'contact_list_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_contacts(
    fields: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    id: Optional[Id] = None,
    number: Optional[Number1] = None,
    contact_list_id: Optional[int] = Query(None, alias='contactListId'),
    property_name: Optional[str] = Query(None, alias='propertyName'),
    property_value: Optional[str] = Query(None, alias='propertyValue'),
):
    """
    Find contacts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/contacts',
    description=""" Creates contacts in CallFire system. Only values from the next list can be used as external system parameter in contact creation: **NATION_BUILDER, SALES_FORCE_CONTACTS, SALES_FORCE_LEADS, SALES_FORCE_REPORTS, ZOHO, MAIL_CHIMP**. See [contacts validation rules](https://www.callfire.com/help/docs/getting-started/managing-contacts/validating-contacts#section1) """,
    tags=['contact_record_management', 'contact_list_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_contacts(body: ContactsPostRequest = None):
    """
    Create contacts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contacts/dncs',
    description=""" Searches for all Do Not Contact (DNC) objects created by user. These DoNotContact entries only affect calls/texts/campaigns on this account. Returns a paged list of DoNotContact objects """,
    tags=['dnc_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_do_not_contacts(
    fields: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    prefix: Optional[str] = None,
    campaign_id: Optional[int] = Query(None, alias='campaignId'),
    source: Optional[str] = None,
    call: Optional[bool] = None,
    text: Optional[bool] = None,
    inbound_call: Optional[bool] = Query(None, alias='inboundCall'),
    inbound_text: Optional[bool] = Query(None, alias='inboundText'),
    number: Optional[Number1] = None,
):
    """
    Find do not contact (dnc) items
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/contacts/dncs',
    description=""" Add or update a list of Do Not Contact (DNC) contact entries. Can toggle whether the DNCs are enabled for calls/texts. """,
    tags=['dnc_record_management', 'contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def add_do_not_contacts(body: AddDoNotContactRequest = None):
    """
    Add do not contact (dnc) numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/contacts/dncs/sources/{source}',
    description=""" Delete Do Not Contact (DNC) contact entries contained in source. """,
    tags=['dnc_record_management', 'contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_do_not_contacts_by_source(source: str):
    """
    Delete do not contact (dnc) numbers contained in source.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contacts/dncs/universals/{toNumber}',
    description=""" Searches for a UniversalDoNotContact object for a given phone number. Shows whether inbound/outbound actions are allowed for a given number """,
    tags=['dnc_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_universal_do_not_contacts(
    to_number: str = Path(..., alias='toNumber'),
    from_number: Optional[str] = Query(None, alias='fromNumber'),
    fields: Optional[str] = None,
):
    """
    Find universal do not contacts (udnc) associated with toNumber
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/contacts/dncs/{number}',
    description=""" Delete a Do Not Contact (DNC) contact entry. """,
    tags=['dnc_record_management', 'contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_do_not_contact(number: str):
    """
    Delete do not contact (dnc) number. If number contains commas treat as list of numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contacts/dncs/{number}',
    description=""" Get Do Not Contact (DNC) object create by user. This DoNotContact entry only affects calls/texts/campaigns on this account. """,
    tags=['dnc_record_management', 'contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_do_not_contact(number: str):
    """
    Get do not contact (dnc)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/contacts/dncs/{number}',
    description=""" Update a Do Not Contact (DNC) contact entry. Can toggle whether the DNC is enabled for calls/texts. """,
    tags=['dnc_record_management', 'contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_do_not_contact(number: str, body: DoNotContact = None):
    """
    Update an individual do not contact (dnc) number
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contacts/lists',
    description=""" Searches for all contact lists which are available for the current user. Returns a paged list of contact lists """,
    tags=['contact_list_operations', 'contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_contact_lists(
    fields: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    name: Optional[str] = None,
    exact_match: Optional[bool] = Query(None, alias='exactMatch'),
    contact_count: Optional[int] = Query(None, alias='contactCount'),
    order_by: Optional[str] = Query(None, alias='orderBy'),
):
    """
    Find contact lists
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/contacts/lists',
    description=""" Creates a contact list for use with campaigns using 1 of 3 inputs. A List of Contact objects, a list of String E.164 numbers, or a list of CallFire contactIds can be used as the data source for the created contact list. After contact list is added into the CallFire system, contact lists goes through seven system safeguards that check the accuracy and consistency of the data. For example, our system checks that contact number is formatted correctly, is valid, is not duplicated in another contact list, or is not added on a specific DNC list. You can configure to keep/merge or remove contacts which do not complies these rules. If contacts were not added to a contact list after the validation, this means the data needs to be properly formatted and corrected before calling this API """,
    tags=['contact_list_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_contact_list(
    fields: Optional[str] = None, body: CreateContactListRequest = None
):
    """
    Create contact lists
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/contacts/lists/upload',
    description=""" Creates a contact list to be used with campaigns through uploading a .csv file. Returns the id of created list """,
    tags=['contact_list_operations', 'contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_contact_list_from_file(file: UploadFile):
    """
    Create contact list from file
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/contacts/lists/{id}',
    description=""" Deletes a contact list, included contacts will not be deleted. """,
    tags=['contact_list_operations', 'contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_contact_list(id: int):
    """
    Delete a contact list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contacts/lists/{id}',
    description=""" Returns a single ContactList instance for a given contact list id """,
    tags=['contact_record_management', 'contact_list_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_contact_list(id: int, fields: Optional[str] = None):
    """
    Find a specific contact list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/contacts/lists/{id}',
    description=""" Updates contact list instance. """,
    tags=['contact_list_operations', 'contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_contact_list(id: int, body: UpdateContactListRequest = None):
    """
    Update a contact list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/contacts/lists/{id}/items',
    description=""" Deletes contacts from a contact list. List the contact ids in request to delete multiple contacts with one request. """,
    tags=['contact_record_management', 'contact_list_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def remove_contact_list_items(
    id: int, contact_id: Optional[ContactId] = Query(None, alias='contactId')
):
    """
    Delete contacts from a contact list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contacts/lists/{id}/items',
    description=""" Searches for all entries in a contact list with specified id. Returns a paged list of contact entries """,
    tags=['contact_record_management', 'contact_list_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_contact_list_items(
    id: int,
    fields: Optional[str] = None,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
):
    """
    Find contacts in a contact list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/contacts/lists/{id}/items',
    description=""" Adds contacts to a contact list. Available contact sources are: list of the contact entities, list of ids of existing contacts in user's account, list of phone numbers in E.164 format (11-digits) """,
    tags=['contact_list_operations', 'contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def add_contact_list_items(id: int, body: AddContactListContactsRequest = None):
    """
    Add contacts to a contact list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/contacts/lists/{id}/items/{contactId}',
    description=""" Deletes a single contact from a contact list """,
    tags=['contact_record_management', 'contact_list_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def remove_contact_list_item(id: int, contact_id: int = Path(..., alias='contactId')):
    """
    Delete a contact from a contact list
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/contacts/{id}',
    description=""" Deletes a contact instance from account """,
    tags=['contact_record_management', 'contact_list_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_contact(id: int):
    """
    Delete a contact
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contacts/{id}',
    description=""" Returns a Contact instance for a given contact id. Deleted contacts can be still retrieved but will be marked as deleted. Deleted contacts will not be shown in search request. """,
    tags=['contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_contact(id: int, fields: Optional[str] = None):
    """
    Find a specific contact
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/contacts/{id}',
    description=""" Updates a single contact instance with id specified. See [contact validation rules](https://www.callfire.com/help/docs/getting-started/managing-contacts/validating-contacts#section1) """,
    tags=['contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_contact(id: int, body: Contact = None):
    """
    Update a contact
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/contacts/{id}/history',
    description=""" Searches for all texts and calls attributed to a contact. Returns a list of calls and texts a contact has been involved with """,
    tags=['contact_record_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_contact_history(
    id: int,
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    fields: Optional[str] = None,
):
    """
    Find a contact's history
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/keywords',
    description=""" Searches for all keywords available for purchase on the CallFire platform. If a keyword appears in the response, it is available for purchase. List the 'keywords' in a query parameter to search for multiple keywords (at least one keyword should be sent in request). Keyword should only consist of uppercase and lowercase letters and numbers. Number of characters must be greater than 2, but less than 65. """,
    tags=['keyword_configuration_management', 'keyword_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_keywords(keywords: Optional[Keywords] = None):
    """
    Find keywords
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/keywords/leases',
    description=""" Searches for all keywords owned by user. A keyword lease is the ownership information involving a keyword """,
    tags=['keyword_configuration_management', 'keyword_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_keyword_leases(
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    filter: Optional[str] = None,
    label_name: Optional[str] = Query(None, alias='labelName'),
    fields: Optional[str] = None,
):
    """
    Find keyword leases
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/keywords/leases/configs',
    description=""" Searches for all keyword lease configs for the user. Returns a paged list of KeywordConfig """,
    tags=['keyword_configuration_management', 'keyword_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_keyword_lease_configs(
    limit: Optional[int] = 20,
    offset: Optional[int] = 0,
    filter: Optional[str] = None,
    label_name: Optional[str] = Query(None, alias='labelName'),
    fields: Optional[str] = None,
):
    """
    Find keyword lease configs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/keywords/leases/configs/{keyword}',
    description=""" Returns a single KeywordConfig instance for a given keyword lease """,
    tags=['keyword_configuration_management', 'keyword_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_keyword_lease_config(keyword: str, fields: Optional[str] = None):
    """
    Find a specific keyword lease config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/keywords/leases/configs/{keyword}',
    description=""" Updates a keyword lease configuration. Use this API endpoint to enable/disable inbound SMS forwarding, set forward number. Forward number must be in E.164 format) """,
    tags=['keyword_configuration_management', 'keyword_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_keyword_lease_config(keyword: str, body: KeywordConfig = None):
    """
    Update a keyword lease config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/keywords/leases/id/{id}',
    description=""" Get keyword by id """,
    tags=['keyword_configuration_management', 'keyword_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_keyword_lease_by_id(id: int, fields: Optional[str] = None):
    """
    Find a keyword by id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/keywords/leases/{keyword}',
    description=""" Searches for all keywords owned by user """,
    tags=['keyword_configuration_management', 'keyword_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_keyword_lease(keyword: str, fields: Optional[str] = None):
    """
    Find a specific lease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/keywords/leases/{keyword}',
    description=""" Updates a keyword lease. Turns the autoRenew on/off. Configure double opt in feature. Add/remove contact list from keyword. """,
    tags=['keyword_configuration_management', 'keyword_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_keyword_lease(keyword: str, body: KeywordLease = None):
    """
    Update a lease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/keywords/{keyword}/available',
    description=""" Searches for the specific keyword to purchase on the CallFire platform. Returns 'true' if keyword is available. Keyword should only consist of uppercase and lowercase letters and numbers. Number of characters must be greater than 2, but less than 65. """,
    tags=['keyword_configuration_management', 'keyword_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def is_keyword_available(keyword: str):
    """
    Check for a specific keyword
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/account',
    description=""" Searches for the user account details. Details include name, email, and basic account permissions. For authentication use api credentials. """,
    tags=['billing_information_management', 'api_credentials_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_account(fields: Optional[str] = None):
    """
    Find account details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/api/credentials',
    description=""" Searches for all credentials generated by user. Returns a paged list of the API credentials. Only ACCOUNT_HOLDER can invoke this API. For authentication use account credentials. """,
    tags=['api_credentials_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_api_credentials(
    name: Optional[str] = None,
    fields: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
):
    """
    Find api credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/me/api/credentials',
    description=""" Creates an API credentials for the CallFire API. This endpoint requires full CallFire account credentials to be used, authenticated using Basic Authentication. At the moment user provides only the name for the credentials. The generated credentials can be used to access any CallFire APIs. For authentication use account credentials. """,
    tags=['api_credentials_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_api_credential(body: ApiCredential = None):
    """
    Create api credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/me/api/credentials/{id}',
    description=""" Deletes a specified API credential. Currently, removes the ability to access the API. Only ACCOUNT_HOLDER can invoke this API. For authentication use account credentials. """,
    tags=['api_credentials_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_api_credential(id: int):
    """
    Delete api credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/api/credentials/{id}',
    description=""" Returns an API credential instance for a given api credential id. Only ACCOUNT_HOLDER can invoke this API. For authentication use account credentials. """,
    tags=['api_credentials_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_api_credential(id: int, fields: Optional[str] = None):
    """
    Find a specific api credential
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/me/api/credentials/{id}/disable',
    description=""" Disables a specified API credential. Currently, removes the ability to access the API. Only ACCOUNT_HOLDER can invoke this API. For authentication use account credentials. """,
    tags=['api_credentials_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def disable_api_credentials(id: int):
    """
    Disable specified API credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/me/api/credentials/{id}/enable',
    description=""" Enables a specified API credential. Currently, adds the ability to access the API. Only ACCOUNT_HOLDER can invoke this API. For authentication use account credentials. """,
    tags=['api_credentials_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def enable_api_credentials(id: int):
    """
    Enable specified API credentials
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/billing/credit-usage',
    description=""" Find credit usage for the user. Returns credits usage for time period specified or if unspecified then total for all time. For authentication use api credentials. """,
    tags=['billing_information_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_credit_usage(
    interval_begin: Optional[int] = Query(None, alias='intervalBegin'),
    interval_end: Optional[int] = Query(None, alias='intervalEnd'),
):
    """
    Find credit usage
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/billing/plan-usage',
    description=""" Searches for the data of a billing plan usage for the user. Returns the data of a billing plan usage for the current month. For authentication use api credentials. """,
    tags=['billing_information_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_billing_plan_usage():
    """
    Find plan usage
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/me/callerids',
    description=""" Returns a list of verified caller ids. If the number is not shown in the list, then it is not verified. In this case sending of a verification code is required. For authentication use api credentials. """,
    tags=['caller_id_operations', 'call_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_caller_ids():
    """
    Find caller ids
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/me/callerids/{callerid}',
    description=""" Generates and sends a verification code to the phone number provided in the path. The verification code is delivered via a phone call. This code needs to be submitted to the verify caller id API endpoint to complete verification. For authentication use api credentials. """,
    tags=['caller_id_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def send_verification_code_to_caller_id(callerid: str):
    """
    Create a caller id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/me/callerids/{callerid}/verification-code',
    description=""" With the verification code received from the Create caller id endpoint, a call to this endpoint is required to finish verification. For authentication use api credentials. """,
    tags=['caller_id_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def verify_caller_id(callerid: str, body: CallerIdVerificationRequest = None):
    """
    Verify a caller id
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/media',
    description=""" Find media files created by user """,
    tags=['media_file_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_media(
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    filter: Optional[str] = None,
    fields: Optional[str] = None,
):
    """
    Find media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/media',
    description=""" Uploads media file to account, acceptable media formats: bmp, gif, jpg, m4a, mp3, mp4, png, wav """,
    tags=['media_file_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_media(file: UploadFile):
    """
    Create media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/media/public/{key}.{extension}',
    description=""" Download a media file. Available types of files: bmp, gif, jpg, m4a, mp3, mp4, png, wav. Content type in response depends on 'extension' parameter, e.g. image/jpeg, image/png, audio/mp3, etc """,
    tags=['media_file_management', 'audio_file_handling'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_media_data_by_key(key: str, extension: str = ...):
    """
    Download media by extension
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/media/{id}',
    description=""" Get media resource by id """,
    tags=['media_file_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_media(id: int, fields: Optional[str] = None):
    """
    Get a specific media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/media/{id}.{extension}',
    description=""" Download a media file. Available types of files: bmp, gif, jpg, m4a, mp3, mp4, png, wav. Content type in response depends on 'extension' parameter, e.g. image/jpeg, image/png, audio/mp3, etc """,
    tags=['media_file_management', 'audio_file_handling'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_media_data(id: int, extension: str = ...):
    """
    Download media by extension
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/media/{id}/file',
    description=""" Download a MP3 media, endpoint returns application/binary content-type """,
    tags=['call_recording_access', 'media_file_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_media_data_binary(id: int):
    """
    Download a MP3 media
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/numbers/leases',
    description=""" Searches for all numbers leased by account user. This API is useful for finding all numbers currently owned by the user. Returns a paged list of number leases. """,
    tags=['keyword_lease_operations', 'number_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_number_leases(
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    prefix: Optional[str] = None,
    city: Optional[str] = None,
    state: Optional[str] = None,
    zipcode: Optional[str] = None,
    label_name: Optional[str] = Query(None, alias='labelName'),
    toll_free: Optional[bool] = Query(None, alias='tollFree'),
    fields: Optional[str] = None,
):
    """
    Find leases
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/numbers/leases/configs',
    description=""" Searches for all number lease configs for the user. Returns a paged list of NumberConfig """,
    tags=[
        'keyword_configuration_management',
        'keyword_lease_operations',
        'number_lease_operations',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_number_lease_configs(
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    prefix: Optional[str] = None,
    city: Optional[str] = None,
    state: Optional[str] = None,
    zipcode: Optional[str] = None,
    label_name: Optional[str] = Query(None, alias='labelName'),
    fields: Optional[str] = None,
):
    """
    Find lease configs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/numbers/leases/configs/{number}',
    description=""" Returns a single NumberConfig instance for a given number lease """,
    tags=[
        'keyword_configuration_management',
        'keyword_lease_operations',
        'number_lease_operations',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_number_lease_config(number: str, fields: Optional[str] = None):
    """
    Find a specific lease config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/numbers/leases/configs/{number}',
    description=""" Updates a phone number lease configuration. Use this API endpoint to add an Inbound IVR or Call Tracking feature to a CallFire phone number. Call tracking configuration allows you to track the incoming calls, to analyze and to respond customers using sms or voice replies. For more information see [call tracking page](https://www.callfire.com/products/call-tracking) """,
    tags=[
        'keyword_configuration_management',
        'keyword_lease_operations',
        'number_lease_operations',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_number_lease_config(number: str, body: NumberConfig = None):
    """
    Update a lease config
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/numbers/leases/{number}',
    description=""" Returns a single NumberLease instance for a given number """,
    tags=['keyword_lease_operations', 'number_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_number_lease(number: str, fields: Optional[str] = None):
    """
    Find a specific lease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/numbers/leases/{number}',
    description=""" Updates a number lease instance. Ability to turn on/off autoRenew and toggle call/text features for a particular number """,
    tags=['keyword_lease_operations', 'number_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_number_lease(number: str, body: NumberLease = None):
    """
    Update a lease
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/numbers/local',
    description=""" Searches for numbers available for purchase in CallFire local numbers catalog . At least one additional parameter is required. User may filter local numbers by their region information. If all numbers with desirable zip code is already busy search will return available numbers with nearest zip code. """,
    tags=['number_availability_search', 'call_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_numbers_local(
    limit: Optional[int] = 100,
    prefix: Optional[str] = None,
    city: Optional[str] = None,
    state: Optional[str] = None,
    zipcode: Optional[str] = None,
    fields: Optional[str] = None,
):
    """
    Find local numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/numbers/regions',
    description=""" Searches for region information. Use this API to obtain detailed region information that can be used to query for more specific phone numbers than a general query. """,
    tags=['number_availability_search'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_number_regions(
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    prefix: Optional[str] = None,
    city: Optional[str] = None,
    city_prefix: Optional[str] = Query(None, alias='cityPrefix'),
    state: Optional[str] = None,
    zipcode: Optional[str] = None,
    country: Optional[str] = None,
    fields: Optional[str] = None,
):
    """
    Find number regions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/numbers/tollfree',
    description=""" Searches for the toll free numbers which are available for purchase in the CallFire catalog """,
    tags=['number_availability_search'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_numbers_tollfree(
    pattern: Optional[str] = None,
    limit: Optional[int] = 100,
    fields: Optional[str] = None,
):
    """
    Find tollfree numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/orders',
    description=""" Searches for account orders """,
    tags=['order_handling'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_orders(
    limit: Optional[int] = 20,
    offset: Optional[int] = 0,
    fields: Optional[str] = None,
    status: Optional[Status9] = None,
    interval_begin: Optional[int] = Query(None, alias='intervalBegin'),
    interval_end: Optional[int] = Query(None, alias='intervalEnd'),
):
    """
    Find orders
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/orders/keywords',
    description=""" Purchase keywords. Send a list of available keywords into this API to purchase them using CallFire credits. Make sure the account has enough credits before trying to purchase the keywords. Keyword should only consist of uppercase and lowercase letters and numbers. Number of characters must be greater than 2, but less than 65. """,
    tags=[
        'keyword_configuration_management',
        'keyword_lease_operations',
        'order_handling',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def order_keywords(fields: Optional[str] = None, body: KeywordPurchaseRequest = None):
    """
    Purchase keywords
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/orders/numbers',
    description=""" Purchase numbers. There are many ways to purchase a number. Set either 'tollFreeCount' or 'localCount' along with some querying fields to purchase numbers by bulk query. Set the list of numbers to purchase by list. Available numbers will be purchased using CallFire credits owned by the user. Make sure the account has enough credits before trying to purchase """,
    tags=['order_handling', 'number_lease_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def order_numbers(fields: Optional[str] = None, body: NumberPurchaseRequest = None):
    """
    Purchase numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/orders/{id}',
    description=""" Returns a single NumberOrder instance for a given order id. Order contains information about purchased keywords, local, toll-free numbers """,
    tags=['order_handling'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_order(id: int, fields: Optional[str] = None):
    """
    Find a specific order
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reports/delivery',
    description=""" Get delivery reports """,
    tags=['text_message_operations', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_delivery_reports(
    start_date: Optional[str] = Query(None, alias='startDate'),
    end_date: Optional[str] = Query(None, alias='endDate'),
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    campaign_id: Optional[int] = Query(None, alias='campaignId'),
    from_number: Optional[str] = Query(None, alias='fromNumber'),
    to_number: Optional[str] = Query(None, alias='toNumber'),
    delivery_category: Optional[DeliveryCategory] = Query(
        None, alias='deliveryCategory'
    ),
    delivery_state: Optional[DeliveryState] = Query(None, alias='deliveryState'),
    carrier: Optional[str] = None,
    message_text: Optional[str] = Query(None, alias='messageText'),
):
    """
    Get delivery reports by ad hoc criteria
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/texts',
    description=""" Searches for texts sent or received by user. Use "campaignId=0" parameter to query for all texts sent through the POST /texts API. See [call states and results](https://developers.callfire.com/results-responses-errors.html) """,
    tags=['text_message_operations', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_texts(
    id: Optional[Id] = None,
    campaign_id: Optional[int] = Query(None, alias='campaignId'),
    batch_id: Optional[int] = Query(None, alias='batchId'),
    from_number: Optional[str] = Query(None, alias='fromNumber'),
    to_number: Optional[str] = Query(None, alias='toNumber'),
    label: Optional[str] = None,
    states: Optional[str] = None,
    results: Optional[str] = None,
    inbound: Optional[bool] = None,
    interval_begin: Optional[int] = Query(None, alias='intervalBegin'),
    interval_end: Optional[int] = Query(None, alias='intervalEnd'),
    limit: Optional[int] = 10,
    offset: Optional[int] = 0,
    fields: Optional[str] = None,
):
    """
    Find texts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/texts',
    description=""" Use the /texts API to send individual texts quickly. By default all texts are going out from CallFire's dedicated short code. Example: 67076, 818818 etc """,
    tags=['text_message_operations', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def send_texts(
    fields: Optional[str] = None,
    campaign_id: Optional[int] = Query(None, alias='campaignId'),
    default_message: Optional[str] = Query(None, alias='defaultMessage'),
    strict_validation: Optional[bool] = Query(None, alias='strictValidation'),
    body: TextsPostRequest = None,
):
    """
    Send texts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/texts/auto-replys',
    description=""" Find all text autoreplies created by user. Returns a paged list of TextAutoReply """,
    tags=['text_message_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_text_auto_replys(
    fields: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    number: Optional[str] = None,
):
    """
    Find auto replies
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/texts/auto-replys',
    description=""" CallFire gives you possibility to set up auto reply messages for your numbers and keywords. You can set a general auto reply for anyone who texts your number, keyword, and/or include a text to match, so that the auto reply would be sent only to those who text the matched text """,
    tags=['text_message_operations', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_text_auto_reply(body: TextAutoReply = None):
    """
    Create an auto reply
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/texts/auto-replys/{id}',
    description=""" Deletes a text auto reply and removes the configuration. Can not delete a TextAutoReply which is currently active for a campaign """,
    tags=['text_message_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_text_auto_reply(id: int):
    """
    Delete an auto reply
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/texts/auto-replys/{id}',
    description=""" Returns a single TextAutoReply instance for a given text auto reply id """,
    tags=['text_message_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_text_auto_reply(id: int, fields: Optional[str] = None):
    """
    Find a specific auto reply
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/texts/broadcasts',
    description=""" Searches for all text broadcasts created by user. Can query on label, name, and the current running status of the campaign. Returns a paged list of text broadcasts """,
    tags=['text_broadcast_management', 'call_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_text_broadcasts(
    name: Optional[str] = None,
    label: Optional[str] = None,
    running: Optional[bool] = None,
    scheduled: Optional[bool] = None,
    interval_begin: Optional[int] = Query(None, alias='intervalBegin'),
    interval_end: Optional[int] = Query(None, alias='intervalEnd'),
    limit: Optional[int] = 10,
    offset: Optional[int] = 0,
    fields: Optional[str] = None,
):
    """
    Find text broadcasts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/texts/broadcasts',
    description=""" Creates a text broadcast campaign using the Text Broadcast API. Send a TextBroadcast object in the message body to detail a text broadcast campaign. A campaign can be created without contacts and with bare minimum configuration, but contacts have to be added further on to use the campaign. It supports scheduling, retry logic, pattern-based messages. """,
    tags=['call_broadcast_management', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_text_broadcast(
    start: Optional[bool] = None,
    strict_validation: Optional[bool] = Query(None, alias='strictValidation'),
    body: TextBroadcast = None,
):
    """
    Create a text broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/texts/broadcasts/{id}',
    description=""" Returns a single TextBroadcast instance for a given text broadcast id """,
    tags=['call_broadcast_management', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_text_broadcast(id: int, fields: Optional[str] = None):
    """
    Find a specific text broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/texts/broadcasts/{id}',
    description=""" Allows modifying the configuration of existing text broadcast campaign. See TextBroadcast for more information on what can/can't be updated on this API """,
    tags=['call_broadcast_management', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_text_broadcast(
    id: int,
    strict_validation: Optional[bool] = Query(None, alias='strictValidation'),
    body: TextBroadcast = None,
):
    """
    Update a text broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/texts/broadcasts/{id}/archive',
    description=""" Archives a text broadcast (and hides it in the search results) """,
    tags=['call_broadcast_management', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def archive_text_broadcast(id: int):
    """
    Archive text broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/texts/broadcasts/{id}/batches',
    description=""" This endpoint will enable the user to page through all of the batches for a particular text broadcast campaign """,
    tags=[
        'call_broadcast_management',
        'campaign_batch_management',
        'text_broadcast_management',
    ],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_text_broadcast_batches(
    id: int,
    fields: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
):
    """
    Find batches in a text broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/texts/broadcasts/{id}/batches',
    description=""" Allows adding an extra batches to an already created text broadcast campaign. The batches which being  added pass the CallFire validation process (unlike in the recipients version of this API). That is why using of a scrubDuplicates flag remove duplicates from your batch. Batches may be added as a contact list id, a list of contact ids, or a list of numbers """,
    tags=['call_broadcast_management', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def add_text_broadcast_batch(
    id: int,
    strict_validation: Optional[bool] = Query(None, alias='strictValidation'),
    body: BatchRequest = None,
):
    """
    Add batches to a text broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/texts/broadcasts/{id}/recipients',
    description=""" Use this API to add recipients to a text broadcast which is already created. Post a list of Recipient objects to be immediately added to the text broadcast campaign. These contacts will not go through validation process, and will be acted upon as they are added. Recipients may be added as a list of contact ids, or list of numbers """,
    tags=['text_broadcast_management', 'text_message_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def add_text_broadcast_recipients(
    id: int,
    fields: Optional[str] = None,
    strict_validation: Optional[bool] = Query(None, alias='strictValidation'),
    body: TextsBroadcastsIdRecipientsPostRequest = None,
):
    """
    Add recipients to a text broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/texts/broadcasts/{id}/start',
    description=""" Starts a text broadcast """,
    tags=['call_broadcast_management', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def start_text_broadcast(id: int):
    """
    Start text broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/texts/broadcasts/{id}/stats',
    description=""" Returns the broadcast statistics. Example: total number of the sent/received actions, total cost, number of remaining outbound actions, error count, etc """,
    tags=['call_broadcast_management', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_text_broadcast_stats(
    id: int,
    fields: Optional[str] = None,
    begin: Optional[int] = None,
    end: Optional[int] = None,
):
    """
    Get statistics on text broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/texts/broadcasts/{id}/stop',
    description=""" Stops a text broadcast """,
    tags=['call_broadcast_management', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def stop_text_broadcast(id: int):
    """
    Stop text broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/texts/broadcasts/{id}/texts',
    description=""" This endpoint will enable the user to page through all of the texts for a particular text broadcast campaign """,
    tags=['text_broadcast_management', 'text_message_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_text_broadcast_texts(
    id: int,
    batch_id: Optional[int] = Query(None, alias='batchId'),
    fields: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
):
    """
    Find texts in a text broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/texts/broadcasts/{id}/toggleRecipientsStatus',
    description=""" This operation lets the user to disable/enable undialed contacts in created broadcast """,
    tags=['call_broadcast_management', 'text_broadcast_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def toggle_text_broadcast_recipients_status(
    id: int,
    enable: Optional[bool] = False,
    body: TextsBroadcastsIdToggleRecipientsStatusPostRequest = None,
):
    """
    Disable/enable undialed recipients in broadcast
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/texts/{id}',
    description=""" Returns a single Text instance for a given text id """,
    tags=['media_file_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_text(id: int, fields: Optional[str] = None):
    """
    Find a specific text
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/webhooks',
    description=""" Searches all webhooks available for a current user. Searches by name, resource, event, callback URL, or whether they are enabled. Returns a paged list of Webhooks """,
    tags=['webhook_configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_webhooks(
    fields: Optional[str] = None,
    limit: Optional[int] = 100,
    offset: Optional[int] = 0,
    name: Optional[str] = None,
    resource: Optional[str] = None,
    event: Optional[str] = None,
    callback: Optional[str] = None,
    enabled: Optional[bool] = None,
):
    """
    Find webhooks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/webhooks',
    description=""" Create a Webhook for notification in the CallFire system. Use the webhooks API to receive notifications of important CallFire events. Select the resource to listen to, and then choose the resource events to receive notifications on. When an event triggers, a POST will be made to the callback URL with a payload of notification information. Available resources and their events include 'CccCampaign': ['started', 'stopped', 'finished'], 'CallBroadcast': ['started', 'stopped', 'finished'], 'TextBroadcast': ['started', 'stopped', 'finished'], 'OutboundCall': ['finished'], 'InboundCall': ['finished'], 'OutboundText': ['finished'], 'InboundText': ['finished'], 'ContactList': ['validationFinished', 'validationFailed'], 'MonthlyRenewal': ['failed', 'finished'], 'LowBalance': ['failed', 'finished']. Webhooks support secret token which is used as signing key to HmacSHA1 hash of json payload which is returned in 'X-CallFire-Signature' header. This header can be used to verify callback POST is coming from CallFire. See [security guide](https://developers.callfire.com/security-guide.html) """,
    tags=['webhook_configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def create_webhook(body: Webhook = None):
    """
    Create a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/webhooks/resources',
    description=""" Searches for webhook resources. Available resources include 'CccCampaign': ['started', 'stopped', 'finished'], 'CallBroadcast': ['started', 'stopped', 'finished'], 'TextBroadcast': ['started', 'stopped', 'finished'], 'OutboundCall': ['finished'], 'InboundCall': ['finished'], 'OutboundText': ['finished'], 'InboundText': ['finished'], 'ContactList': ['validationFinished', 'validationFailed'], 'MonthlyRenewal': ['failed', 'finished'], 'LowBalance': ['failed', 'finished'] """,
    tags=['webhook_configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def find_webhook_resources(fields: Optional[str] = None):
    """
    Find webhook resources
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/webhooks/resources/{resource}',
    description=""" Returns information about supported events for a given webhook resource """,
    tags=['webhook_configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_webhook_resource(resource: str, fields: Optional[str] = None):
    """
    Find specific webhook resource
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/webhooks/{id}',
    description=""" Deletes a webhook instance. Will be removed permanently """,
    tags=['webhook_configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_webhook(id: int):
    """
    Delete a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/webhooks/{id}',
    description=""" Returns a single Webhook instance for a given webhook id """,
    tags=['webhook_configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_webhook(id: int, fields: Optional[str] = None):
    """
    Find a specific webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/webhooks/{id}',
    description=""" Updates the information in existing webhook """,
    tags=['webhook_configuration_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def update_webhook(id: int, body: Webhook = None):
    """
    Update a webhook
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
